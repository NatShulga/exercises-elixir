
Так как процессы изолированы друг от друга, то возникновение ошибки в одном процессе никак не отражается на работе остальных:

```elixir
spawn(fn -> raise "boom" end)
# => 17:27:46.980 [error] Process #PID<0.277.0> raised an exception
# => ** (RuntimeError) boom
# =>     iex:156: (file)
```

Однако, в некоторых ситуациях нужно, чтобы процессы были связаны между собой для обработки ошибок. Создание связи происходит через функцию `spawn_link`:

```elixir
self()
# => #PID<0.105.0>

spawn_link(fn -> raise "boom" end)
# => ** (EXIT from #PID<0.105.0>) shell process exited with reason: an exception was raised:
# =>     ** (RuntimeError) boom
# =>         iex:158: (file)

# => 17:30:45.109 [error] Process #PID<0.280.0> raised an exception
# => ** (RuntimeError) boom
# =>     iex:158: (file)
```

Теперь, когда процессы связаны, возникновение ошибки в созданном процессе так же вызвало ошибку и в процессе, с которым он был связан. По сути, связанный процесс получил сигнал `EXIT` и аварийно завершился.

Благодаря связям, можно создавать процессы *супервизоры* (supervisors), которые следят за порожденными процессами *рабочими* (workers). При возникновении внештатных ситуаций процесс супервизор перезапускает наблюдаемый им процесс. Такая архитектура лежит в основе Elixir и Erlang приложений и называется *дерево супервизии*, внутри которого отдельные процессы супервизоры запускают другие процессы и следят за их работой, перезапуская при необходимости. Корнем в этом дереве выступает само приложение, внутри которого запущены остальные процессы. Выглядит дерево супервизии примерно так:

```elixir
#                      супервизор игровой сессии       -- обработчики игровых сессий
#                    /
# процесс приложения  -- супервизор обработки платежей -- обработчики платежей
#                    \
#                      супервизор рассылки уведомлений -- отправители уведомлений
```

Теперь рассмотрим причины завершения процессов. Когда процесс заканчивает свою работу, он *завершается* (finishes) в *нормальном* (normal) режиме, по сути нормальное завершение процесса выглядит как прямой вызов функции `exit(:normal)` из модуля `Process`:

```elixir
spawn_link(fn -> exit(:normal) end)
# => #PID<0.282.0>
spawn(fn -> exit(:normal) end)
# => #PID<0.283.0>
```

Результат работы функций идентичный из-за завершения процесса в режиме `:normal`. Если же причина будет другой, то завершение процесса будет расцениваться как *аварийное*:

```elixir
spawn(fn -> exit(:boom_reason) end)
# => #PID<0.284.0>

spawn_link(fn -> exit(:boom_reason) end)
# => ** (EXIT from #PID<0.281.0>) shell process exited with reason: :boom_reason
#
# => Interactive Elixir (1.15.0) - press Ctrl+C to exit (type h() ENTER for help)
```

Так как процесс интерактивной оболочки был связан напрямую с новым процессом, который аварийно завершился, то процесс интерактивной оболочки тоже аварийно завершился. А дальше *супервизор интерактивной оболочки* перехватил аварийное завершение *процесса-оболочки* и перезапустил его.

Именно так и работает дерево супервизии. Но для перезапуска нужно как-то понять, каким образом завершился наблюдаемый процесс. Для этих целей используется перехват выхода или перехват завершения процесса (trap exits) через специальный флаг, который выставляется для настройки процесса. Процессы можно конфигурировать, например размер кучи, приоритет, перехват завершения и многое другое. Нас интересует флаг перехвата, который конвертирует все сигналы завершения процесса в сообщения вида `{'EXIT', from, reason}`. Настройка процессов таким образом не является стандартной практикой, так как фреймворк OTP предоставляет специальную абстракцию под это, которая и называется `Supervisor`. С OTP фреймворком познакомимся чуть позже, когда разберемся как процессы работают на более низком уровне.

Теперь настроим процесс на перехват сигналов о завершении:

```elixir
Process.flag(:trap_exit, true)
# => false

spawn_link(fn -> 1 + 1 end)
# => #PID<0.287.0>
Process.info(self(), :messages)
# => {:messages, [{:EXIT, #PID<0.287.0>, :normal}]}
```

Как видно из кода, процесс посчитал выражение и завершился в штатном режиме. Теперь завершим процесс с другим сигналом:

```elixir
spawn_link(fn -> exit(:not_okay_reason) end)
# => #PID<0.288.0>
Process.info(self(), :messages)
# =>{:messages, [{:EXIT, #PID<0.288.0>, :not_okay_reason}]}
```

Теперь мы можем перехватывать любые сообщения о завершении и реагировать на них:

```elixir
receive do
  {:EXIT, pid, :normal} -> "Process #{inspect(pid)} exited normally"
  {:EXIT, pid, reason} -> "Process #{inspect(pid)} exited abnormally #{reason}"
end
```

Более того, теперь мы можем перехватывать и исключения:

```elixir
spawn_link(fn -> raise "boom!" end)
# => #PID<0.107.0>
#
# => 02:15:35.982 [error] Process #PID<0.107.0> raised an exception
# => ** (RuntimeError) boom!
# =>     iex:4: (file)

Process.info(self(), :messages)
# => {:messages, [{:EXIT, #PID<0.107.0>, {%RuntimeError{message: "boom!"}, [{:elixir_eval, :__FILE__, 1, [file: ~c"iex", line: 4]}]}}]}
```
