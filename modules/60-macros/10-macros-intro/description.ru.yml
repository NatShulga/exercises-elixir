---
name: Знакомство с макросами
theory: |

  Иногда возникает необходимость расширить сам язык, создав предметно-ориентированный язык (DSL), либо реализовать какие-то новые возможности. Elixir с помощью макросов позволяет достичь этого, а сам процесс написания макросов называется метапрограммированием.

  Макросы похожи на функции, но действуют совершенно иначе, чем функции. Объявляется макрос с помощью инструкции `defmacro`. Для начала рассмотрим отличия макросов и функций:

  ```elixir
  # объявим модуль с функцией и макросом
  defmodule Exercise do
    def my_fn(x) do
      IO.inspect(x)
      x
    end

    defmacro my_macro(x) do
      IO.inspect(x)
      x
    end
  end
  ```

  Чтобы воспользоваться макросом, нужно подключить модуль с помощью инструкции `require` в котором макрос объявлен:

  ```elixir
  require Exercise

  Exercise.my_fn(1 + 2)
  # => 3
  # => 3

  Exercise.my_macro(1 + 2)
  # => {:+, [line: 12], [1, 2]}
  # => 3
  ```

  Вызов функции понятен, Elixir вычисляет значение выражения `1 + 2`, затем передает его дальше в функцию, где полученное значение выводится на экран и возвращается из функции. В случае с макросом, вместо вычисления выражения, оно интерпретируется как кортеж, затем этот кортеж выводится на экран и возвращается из макроса, а после интерпретатор Elixir вычисляет возвращенный кортеж.

  Рассмотрим внимательнее кортеж, который оказался в макросе `{:+, [line: 12], [1, 2]}`, где `:+` - оператор, `[line: 12]` - метаданные об операции, `[1, 2]` - список операндов. Теперь, обладая пониманием, что означает этот кортеж, напишем макрос, который удваивает переданный аргумент:

  ```elixir
  defmodule Exercise do
    defmacro double(x) do
      {:*, [], [2, x]}
    end
  end

  require Exercise

  Exercise.double(2)
  # => 4
  Exercise.double(10)
  # => 20
  Exercise.double(2 * 2)
  # => 8
  Exercise.double(2 + 1 - 5)
  # => -4
  ```

  Макрос работает, но выглядит неудобно, в следующем упражнении рассмотрим как сделать макрос более читаемым.

  Интересный факт: создатель языка, Жозе Валим, при добавлении макросов в Elixir, вдохновлялся Clojure.

instructions: |

  Создайте макрос `my_abs`, который берет абсолютное значение переданного аргумента (поможет функция `abs`):

  ```elixir
  require Solution

  Solution.my_abs(-2)
  # => 2
  Solution.my_abs(2)
  # => 2
  Solution.my_abs(-5 * 100)
  # => 500
  Solution.my_abs(-2 - 100 + 1)
  # => 101
  ```

tips:
  - |
    [Официальная документация](https://hexdocs.pm/elixir/1.15.4/Macro.html)
  - |
    [Про DSL](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D0%BC%D0%B5%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA)
  - |
    [Про метапрограммирование](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%B0%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
