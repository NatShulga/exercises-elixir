
Иногда возникает необходимость расширить сам язык, создав предметно-ориентированный язык (DSL), либо реализовать какие-то новые возможности. Elixir с помощью макросов позволяет достичь этого, а сам процесс написания макросов называется метапрограммированием.

Макросы похожи на функции, но действуют совершенно иначе, чем функции. Объявляется макрос с помощью инструкции `defmacro`. Для начала рассмотрим отличия макросов и функций:

```elixir
# объявим модуль с функцией и макросом
defmodule Exercise do
  def my_fn(x) do
    IO.inspect(x)
    x
  end

  defmacro my_macro(x) do
    IO.inspect(x)
    x
  end
end
```

Чтобы воспользоваться макросом, нужно подключить модуль с помощью инструкции `require` в котором макрос объявлен:

```elixir
require Exercise

Exercise.my_fn(1 + 2)
# => 3
# => 3

Exercise.my_macro(1 + 2)
# => {:+, [line: 12], [1, 2]}
# => 3
```

Вызов функции понятен, Elixir вычисляет значение выражения `1 + 2`, затем передает его дальше в функцию, где полученное значение выводится на экран и возвращается из функции. В случае с макросом, вместо вычисления выражения, оно интерпретируется как кортеж, затем этот кортеж выводится на экран и возвращается из макроса, а после интерпретатор Elixir вычисляет возвращенный кортеж.

Рассмотрим внимательнее кортеж, который оказался в макросе `{:+, [line: 12], [1, 2]}`, где `:+` - оператор, `[line: 12]` - метаданные об операции, `[1, 2]` - список операндов. Теперь, обладая пониманием, что означает этот кортеж, напишем макрос, который удваивает переданный аргумент:

```elixir
defmodule Exercise do
  defmacro double(x) do
    {:*, [], [2, x]}
  end
end

require Exercise

Exercise.double(2)
# => 4
Exercise.double(10)
# => 20
Exercise.double(2 * 2)
# => 8
Exercise.double(2 + 1 - 5)
# => -4
```

Макрос работает, но выглядит неудобно, в следующем упражнении рассмотрим как сделать макрос более читаемым.

Интересный факт: создатель языка, Жозе Валим, при добавлении макросов в Elixir, вдохновлялся Clojure.
