---

name: Функции в Elixir
theory: |

  Функции в эликсире, на первый взгляд, похожи на функции обычных императивных языков. Но это только на первый. Как вы увидите дальше, они во многом устроены по другому, что сильно влияет на способ организации кода внутри них.

  Самый простой способ определить функцию – использовать конструкцию _def/do/end_:

  ```elixir
  def hello do
    IO.puts("Hello, World!")
  end
  ```

  Если функция не принимает аргументов, то при ее определении можно не указывать скобок.

  Если функция принимает параметры, то они указываются в определении, так же как и в большинстве других языков:

  ```elixir
  defmodule Math do
    # Имя записывается в snake_case
    def sum_of_values(a, b) do
      # Обычное сложение
      a + b
    end
  end

  # Функция может вызываться без скобок!
  IO.puts Math.sum_of_values(5, 8) # => 13
  ```

  В Эликсире нет инструкции `return`, которая могла бы прервать выполнение кода. Результатом выполнения функции всегда является значение последнего вычисленного выражения. Если функция пустая, то возвращается _nil_, который аналогичен _null_ в других языках.

  Другая особенность, функции можно вызывать без скобок. Раньше такой синтаксис был популярным, но сейчас не принято так делать. Во вложенных вызовах такая запись становится не очевидной: `IO.puts inspect "huh"`.

  Для коротких функций, состоящих из одного выражения, Эликсир поддерживает специальный, сокращенный синтаксис объявления:

  ```elixir
  # Обратите внимание на запятую после описания сигнатуры функции и отсутствие end в конце
  def sum_of_values(a, b), do: a + b

  # или

  def hello, do: IO.puts("Hello, World!")
  ```

  Функции определяемые с помощью `def` доступны для вызова снаружи модуля. Но не все функции создаваемые внутри модуля, создаются для вызовов снаружи. Иногда функции выполняют вспомогательную роль для других функций этого же модуля. В такой ситуации лучше определять функцию через `defp`. Эта конструкция делает функцию приватной, то есть ее становится невозможно вызвать за пределами текущего модуля.

  ```elixir
  defmodule Solution do
    # К функциям из того же модуля можно обращаться без указания модуля
    def hello, do: IO.puts(text_for_hello())

    defp text_for_hello, do: "Hello, World"
  end
  ```

  Помимо именованных функций, можно создавать анонимные в форме `fn (x) -> fn_body end`:

  ```elixir
  sum = fn (x, y) -> x + y end
  sum.(2, 3) # => 5

  magic = fn (a, b, c) -> (a + b) * c end
  magic.(2, 3, 4) # => 20
  ```

  Так как функции в эликсире являются объектами первого класса, то часто приходится писать анонимные функции, которые передаются в другие функции и для сокращения записи таких функций используется оператор `&`:

  ```elixir
  mul = &(&1 * &2)
  mul.(3, 3) # => 9

  magic = &((&1 + &2 + &3) * &4)
  magic.(1, 2, 3, 4) # => 24
  ```
  
  При использовании сокращенного синтаксиса для анонимных функций следует быть аккуратным, так как при большом количестве аргументов можно легко запутаться с их порядком, особенно, если в функции есть сложная логика. 

instructions: |

  Реализуйте функцию `print_twice(value)`, которая печатает на экран переданное значение два раза

  ```elixir
  Solution.print_twice("WoW")
  # => WoW
  # => WoW
  ```

tips:
  - |
    [Про объекты первого класса](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0)
