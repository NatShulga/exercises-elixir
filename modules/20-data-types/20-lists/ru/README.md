
Список — коллекция элементов. В отличие от кортежа, в список можно динамически добавлять и удалять элементы.

Список совсем не похож на массив ни по своему внутреннему устройству, ни по способу работы с ним. По внутреннему устройству это однонаправленный связанный список (singly linked list). А работа с ним сводится к двум простым операциям: добавление нового элемента к голове списка, и разделение списка на голову и хвост.

Создадим список, и добавим в него новый элемент:

```elixir
my_list = [1, 2, 3, 4] # [1, 2, 3, 4]
other_list = [0 | my_list] # [0, 1, 2, 3, 4]
```

Оператор *|* добавляет новый элемент к голове списка и возвращает новый список.

Разделение списка на голову и хвост выглядит похоже:

```elixir
[head | tail] = my_list
IO.puts(head) # => 1
IO.puts(inspect(tail)) # => [2, 3, 4]
```

Здесь мы используем сопоставление с образцом. Шаблон (образец) `[head | tail]` сопоставляется со списком. Первый элемент списка попадает в переменную `head`, остаток списка (хвост) попадает в переменную `tail`.

Можно извлечь несколько элементов одновременно:

```elixir
[item1, item2, item3 | tail] = my_list
IO.puts(item1) # => 1
IO.puts(item2) # => 2
IO.puts(item3) # => 3
IO.puts(inspect(tail)) # => [4]
```

Таким образом мы извлекли три элемента, и в списке остался только один.

Есть еще функции `hd` и `tl`, которые извлекают голову и хвост списка:

```elixir
hd(my_list) # 1
tl(my_list) # [2, 3, 4]
```

Зачем нужны такие странные операции? На них основана итерация по элементам списка. А на итерации основана вообще любая работа со списками и с другими коллекциями. Это станет понятно позже, когда мы начнем изучать рекурсию и основы функционального программирования.
